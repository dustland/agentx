# Multi-Tenant Architecture

> **⚠️ IMPORTANT SECURITY NOTICE**
>
> This multi-tenant implementation provides **organizational isolation only**, not true security isolation. Users can pass any `user_id` parameter to access other users' taskspaces and data. This design is suitable for trusted environments and development scenarios, but **requires external authentication and authorization layers** for production security. See the [Authentication Integration](#authentication-integration) section for secure deployment patterns.

AgentX provides built-in multi-tenant support through taskspace isolation and user-scoped API access. This design ensures that different users can logically separate their work when sharing the same AgentX instance, but relies on external security measures for true access control.

## Overview

Multi-tenancy in AgentX is implemented through the taskspace system, providing user isolation without requiring complex authentication infrastructure. All tasks require a user_id for proper isolation and security.

### Key Security Principles

- **User Isolation**: Each user's tasks and data are completely isolated at the application level
- **Taskspace Segregation**: File system isolation prevents accidental cross-user access
- **API Filtering**: All endpoints filter results by user_id parameter
- **Mandatory User Context**: All operations require a valid user_id

> **Note**: These principles provide organizational separation but do not prevent malicious users from accessing other users' data by manipulating the `user_id` parameter. Production deployments must implement proper authentication and authorization.

## Taskspace Isolation Design

### Directory Structure

```
taskspace/
├── {user_id}/
│   ├── {task_id}/
│   │   ├── artifacts/          # User's task files
│   │   ├── logs/              # Execution logs
│   │   ├── messages/          # Conversation history
│   │   └── plan.json         # Task execution plan
│   └── {another_task_id}/
└── {another_user_id}/
    └── {task_id}/
```

All tasks are stored in the user-scoped format with mandatory user_id association.

## API Security Model

### User-Scoped Endpoints

All task-related endpoints require `user_id` for proper isolation:

```http
# Create user-scoped task
POST /tasks
{
  "config_path": "config/team.yaml",
  "task_description": "Build a website",
  "user_id": "alice"
}

# List user's tasks only
GET /tasks?user_id=alice

# Access user's task data (user_id passed via header or auth context)
GET /tasks/{task_id}
GET /tasks/{task_id}/artifacts
```

### Permission Enforcement

- **Task Creation**: Tasks are created with user_id association
- **Task Listing**: Results filtered by user_id parameter
- **Task Access**: 404 returned for tasks not owned by requesting user
- **Artifact Access**: File system access limited to user's taskspace

> **Security Limitation**: The current implementation trusts the provided `user_id` parameter without validation. Any user can access another user's data by providing their `user_id`. This requires external authentication middleware to validate user identity and enforce proper access controls.

## Implementation Details

### Core Components

#### TaskspaceStorage

```python
class TaskspaceStorage:
    def __init__(self, base_path, task_id, user_id):
        # All tasks use multi-tenant structure: taskspace/{user_id}/{task_id}
        self.taskspace_path = Path(base_path) / user_id / task_id
```

#### XAgent Integration

```python
class XAgent:
    def __init__(self, team_config, user_id):
        self.user_id = user_id  # Required for all tasks
        self.taskspace = StorageFactory.create_taskspace_storage(
            base_path=Path("./taskspace"),
            task_id=self.task_id,
            user_id=self.user_id
        )
```

### API Models

Task-related models require `user_id` fields:

```python
class TaskRequest(BaseModel):
    config_path: str
    task_description: str
    user_id: str  # Required multi-tenant identifier

class TaskResponse(BaseModel):
    task_id: str
    status: TaskStatus
    user_id: str  # Always returned for verification
```

## Security Considerations

### Data Isolation

- **File System**: Complete directory separation by user_id
- **Memory**: Task storage scoped to prevent cross-user access
- **Artifacts**: Git versioning isolated per user taskspace
- **Logs**: Execution logs stored in user-specific directories

> **Critical**: These isolation mechanisms only work when the correct `user_id` is provided. Without proper authentication, users can bypass all isolation by using other users' IDs.

### Path Traversal Protection

The taskspace system includes built-in protection against path traversal attacks:

```python
# Safe: resolves to taskspace/alice/task123/file.txt
taskspace.get_artifact("file.txt")

# Blocked: attempts to access ../bob/task456/ are prevented
# by Path.resolve() and taskspace boundary checks
```

> **Note**: Path traversal protection only works within the specified user's taskspace. Users can still access other users' taskspaces by providing different `user_id` values.

### Resource Limits

While basic isolation is provided, production deployments should implement:

- **Authentication**: Validate user identity before accepting `user_id` parameter
- **Authorization**: Ensure users can only access their own resources
- **Disk quotas** per user
- **Rate limiting** on API endpoints
- **Memory limits** for task execution
- **Concurrent task limits** per user

## Deployment Patterns

### Multi-Tenant Mode (Default)

```bash
# Start AgentX with multi-tenant support
agentx start

# All tasks require user_id for isolated taskspaces
POST /tasks {"user_id": "alice", "config_path": "config.yaml", "task_description": "..."}
```

> **⚠️ SECURITY WARNING**: The above example shows the API structure but is NOT secure. In production, the `user_id` must be derived from authenticated sessions, not passed as a parameter. Direct API access without authentication allows any user to access any other user's data.

### Authentication Integration

AgentX's multi-tenancy requires integration with authentication systems:

> **REQUIRED FOR SECURITY**: The examples below show how to implement proper authentication and authorization. Without this middleware, the multi-tenant system provides no security protection.

```python
# Example: JWT-based user identification
from jwt import decode

async def get_current_user(authorization: str = Header(None)):
    if not authorization:
        raise HTTPException(401, "Authentication required")

    token = authorization.replace("Bearer ", "")
    payload = decode(token, SECRET_KEY, algorithms=["HS256"])
    user_id = payload.get("user_id")

    if not user_id:
        raise HTTPException(401, "Invalid token")

    return user_id

@app.post("/tasks")
async def create_task(request: TaskRequest, user_id: str = Depends(get_current_user)):
    request.user_id = user_id  # Set authenticated user
    # ... create task
```

> **Security Note**: The `user_id` must come from the authenticated session, never from user input. Any endpoint that accepts `user_id` as a parameter without authentication is a security vulnerability.

## Migration Guide

### Upgrading to Multi-Tenant Architecture

1. **Update API calls** to include required `user_id` parameter
2. **Configure authentication** middleware (required)
3. **Migrate existing taskspaces** from legacy format:

```bash
# Migrate legacy taskspaces to user-scoped structure
for task_dir in taskspace/*/; do
    task_id=$(basename "$task_dir")
    if [[ ! "$task_id" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        continue  # Skip if already user-scoped
    fi

    # Move to default user or specify actual user
    mkdir -p "taskspace/default/$task_id"
    mv "$task_dir"/* "taskspace/default/$task_id/"
    rmdir "$task_dir"
done
```

### API Client Updates

```typescript
// Before: Legacy single-tenant
const task = await api.createTask({
  config_path: "config.yaml",
  task_description: "Build website",
});

// After: Multi-tenant (user_id required)
const task = await api.createTask({
  config_path: "config.yaml",
  task_description: "Build website",
  user_id: getCurrentUser().id, // Required field
});
```

## Best Practices

### Security

1. **Ensure user_id is always provided** from authenticated context
2. **Validate user permissions** at the application layer
3. **Use HTTPS** for API communication
4. **Implement rate limiting** to prevent abuse
5. **Monitor resource usage** per user

### Performance

1. **Clean up old taskspaces** periodically
2. **Implement disk quotas** to prevent storage exhaustion
3. **Consider task archival** for long-term storage
4. **Monitor concurrent tasks** per user

### Monitoring

1. **Track taskspace sizes** per user
2. **Monitor API access patterns** for anomalies
3. **Log security events** (unauthorized access attempts)
4. **Set up alerts** for resource threshold breaches

## Example Implementation

### Complete Multi-Tenant Setup

```python
from fastapi import FastAPI, Depends, HTTPException, Header
from agentx.server.api import create_app
from agentx.server.models import TaskRequest

app = create_app()

# API key based authentication (required)
async def get_current_user(api_key: str = Header(None)):
    if not api_key:
        raise HTTPException(401, "API key required")

    # Validate API key and return user_id
    user_id = validate_api_key(api_key)
    if not user_id:
        raise HTTPException(401, "Invalid API key")

    return user_id

@app.post("/tasks")
async def create_task(
    request: TaskRequest,
    user_id: str = Depends(get_current_user)
):
    # Ensure user_id from authentication
    request.user_id = user_id
    return await create_task_endpoint(request)

@app.get("/tasks")
async def list_tasks(user_id: str = Depends(get_current_user)):
    return await list_tasks(user_id=user_id)
```

This multi-tenant architecture provides organizational separation that enables AgentX to be deployed in shared environments with proper external authentication. The framework itself does not provide security isolation - it relies on external authentication systems to validate user identity and enforce access controls. When properly secured with authentication middleware, this design maintains the simplicity and flexibility that makes AgentX easy to use and deploy.
