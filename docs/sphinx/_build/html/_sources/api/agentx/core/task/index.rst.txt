agentx.core.task
================

.. py:module:: agentx.core.task

.. autoapi-nested-parse::

   Task execution class - the primary interface for AgentX task execution.

   Clean API:
       # One-shot execution (Lead-driven)
       await execute_task(prompt, config_path)

       # Step-by-step execution (Lead-driven)
       task = start_task(prompt, config_path)
       await task.run()



Attributes
----------

.. autoapisummary::

   agentx.core.task.logger


Classes
-------

.. autoapisummary::

   agentx.core.task.Task
   agentx.core.task.TaskExecutor


Functions
---------

.. autoapisummary::

   agentx.core.task.execute_task
   agentx.core.task.start_task


Module Contents
---------------

.. py:class:: Task(task_id: str, config: agentx.core.config.TaskConfig, history: agentx.core.message.TaskHistory, message_queue: agentx.core.message.MessageQueue, agents: Dict[str, agentx.core.agent.Agent], workspace: agentx.storage.workspace.WorkspaceStorage, orchestrator: agentx.core.orchestrator.Orchestrator, initial_prompt: str)

   Represents the state and context of a single task being executed.
   This class is a data container and does not have execution logic.


   .. py:method:: complete()

      Marks the task as complete.



   .. py:method:: get_agent(name: str) -> agentx.core.agent.Agent

      Retrieves an agent by name.



   .. py:method:: get_context() -> Dict[str, Any]

      Returns a dictionary with the task's context.



   .. py:attribute:: agents


   .. py:attribute:: config


   .. py:attribute:: created_at
      :type:  datetime.datetime


   .. py:attribute:: history


   .. py:attribute:: initial_prompt


   .. py:attribute:: is_complete
      :type:  bool
      :value: False



   .. py:attribute:: message_queue


   .. py:attribute:: orchestrator


   .. py:attribute:: plan
      :type:  Optional[agentx.core.plan.Plan]


   .. py:attribute:: task_id


   .. py:attribute:: workspace


.. py:class:: TaskExecutor(team_config: Union[agentx.core.config.TeamConfig, str], task_id: Optional[str] = None, workspace_dir: Optional[pathlib.Path] = None)

   The main engine for executing a task. It coordinates the agents, tools,
   and orchestrator to fulfill the user's request.


   .. py:method:: start(prompt: str, stream: bool = False) -> AsyncGenerator[agentx.core.message.Message, None]
      :async:


      Starts the task execution and streams back events.



   .. py:attribute:: agents


   .. py:attribute:: history


   .. py:attribute:: message_queue


   .. py:attribute:: orchestrator


   .. py:attribute:: task
      :type:  Optional[Task]
      :value: None



   .. py:attribute:: task_id
      :value: ''



   .. py:attribute:: tool_manager


   .. py:attribute:: workspace


.. py:function:: execute_task(prompt: str, config_path: str, stream: bool = False) -> AsyncGenerator[agentx.core.message.Message, None]
   :async:


   High-level function to execute a task from a prompt and config file.
   This function runs the task to completion autonomously.


.. py:function:: start_task(prompt: str, config_path: str, task_id: Optional[str] = None, workspace_dir: Optional[pathlib.Path] = None) -> TaskExecutor

   High-level function to start a task and return the TaskExecutor for step-by-step execution.

   This function is ideal for interactive scenarios where you want to:
   - Execute tasks step by step
   - Inspect task state between steps
   - Modify task configuration during execution
   - Build interactive UIs with manual control

   :param prompt: The initial task prompt
   :param config_path: Path to the team configuration file
   :param task_id: Optional custom task ID
   :param workspace_dir: Optional custom workspace directory

   :returns: The initialized executor ready for step-by-step execution
   :rtype: TaskExecutor

   .. rubric:: Example

   ```python
   # Start a task for step-by-step execution
   executor = start_task(
       prompt="Write a research report",
       config_path="config/team.yaml"
   )

   # Execute steps manually
   async for message in executor.start(prompt, stream=True):
       print(f"Agent: {message.agent_name}")
       print(f"Content: {message.content}")

       # You can inspect state, pause, or modify between steps
       if some_condition:
           break
   ```


.. py:data:: logger

