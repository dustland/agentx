# 03: Data Structures & Event Model

This document specifies the core data objects that flow through the Roboco framework and the event model used for real-time observability. It builds on the architecture and collaboration models defined in the previous documents.

## 1. The `TaskStep` Object

The `TaskStep` is the fundamental unit of history. It represents a single, complete turn taken by an entity (an agent or a tool executor) in the system.

- **(Req #13)** The `TaskStep` is designed to be extensible and support multimodal data through its `parts` structure.

**Schema:**

```python
class TaskStep(BaseModel):
    step_id: str = Field(default_factory=lambda: f"step_{uuid.uuid4().hex}")
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    agent_name: str  # The agent or system component that generated this step
    parts: List[Union[TextPart, ToolCallPart, ToolResultPart, ArtifactPart]]
```

## 2. `TaskStep` Parts

A `TaskStep` is composed of one or more `Part`s, each representing a different kind of data.

### `TextPart`

Contains text generated by an agent or user.

```python
class TextPart(BaseModel):
    type: Literal["text"] = "text"
    text: str
```

### `ToolCallPart`

A structured request from an agent to call a tool.

```python
class ToolCall(BaseModel):
    id: str = Field(default_factory=lambda: f"tc_{uuid.uuid4().hex}")
    tool_name: str
    args: Dict[str, Any]

class ToolCallPart(BaseModel):
    type: Literal["tool_call"] = "tool_call"
    tool_call: ToolCall
```

### `ToolResultPart`

The output from the `ToolExecutorAgent` after running a tool. It is explicitly linked to a `ToolCall` by its `tool_call_id`.

```python
class ToolResult(BaseModel):
    tool_call_id: str
    result: str # The stdout or serialized result from the tool
    error: Optional[str] = None # Stderr if the tool failed

class ToolResultPart(BaseModel):
    type: Literal["tool_result"] = "tool_result"
    tool_result: ToolResult
```

### `ArtifactPart`

A reference to a file in the `Task Workspace`. This allows the history to remain lightweight while handling large data like generated code, images, or documents.

```python
class Artifact(BaseModel):
    uri: str  # e.g., "file://artifacts/main.py"
    mime_type: str

class ArtifactPart(BaseModel):
    type: Literal["artifact"] = "artifact"
    artifact: Artifact
```

## 3. The Dual-Channel Event Model

To provide a rich, observable, and UI-friendly experience, the `Orchestrator` will produce two distinct streams of information for the client.

- **(Req #11, #15)** This model ensures clients can get both low-latency text streaming and high-level structured events about the task's lifecycle.

### Channel 1: The Content Stream (`StreamChunk`)

This channel provides real-time, token-by-token output directly from the LLM. It is designed for low-latency UI updates.

**Schema:**

```python
class StreamChunk(BaseModel):
    type: Literal["content_chunk"] = "content_chunk"
    text: str
```

As the `Orchestrator` receives tokens from the agent's "Brain", it immediately forwards them on this stream.

### Channel 2: The Execution Event Stream (`ExecutionEvent`)

This channel provides structured updates about significant lifecycle events within the `Orchestrator`. These events are used for building robust UIs, logging, and debugging.

**Schema (Example Events):**

```python
class TaskStartEvent(BaseModel):
    type: Literal["event_task_start"] = "event_task_start"
    task_id: str
    timestamp: datetime

class AgentHandoffEvent(BaseModel):
    type: Literal["event_agent_handoff"] = "event_agent_handoff"
    from_agent: str
    to_agent: str
    reason: str

class ToolCallEvent(BaseModel):
    type: Literal["event_tool_call"] = "event_tool_call"
    tool_call: ToolCall

class ToolResultEvent(BaseModel):
    type: Literal["event_tool_result"] = "event_tool_result"
    tool_result: ToolResult
```

The `Orchestrator` will emit these events as it performs actions like starting a task, processing a handoff, dispatching a tool call, or receiving a result. This gives the client a complete, real-time picture of the task's state.

## 4. Design Complete

With this document, the full design specification for the Roboco framework is complete. We have defined:

1.  The high-level **Architecture**.
2.  The core **Collaboration & Planning Model**.
3.  The detailed **Data Structures & Event Model**.

This provides a sufficient blueprint to begin implementation.
